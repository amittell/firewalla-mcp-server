/**
 * @fileoverview Contract Tests for Firewalla API Response Schemas
 * 
 * Validates that our mock responses and actual API responses conform to expected schemas.
 * This catches API drift and ensures our code handles the correct data structures.
 */

import { ToolRegistry } from '../../src/tools/registry.js';
import { createMockFirewallaClient, mockResponses } from '../mocks/mockFirewallaClient.js';

describe('Firewalla API Contract Tests', () => {
  let registry: ToolRegistry;
  let mockClient: any;

  beforeEach(() => {
    registry = new ToolRegistry();
    mockClient = createMockFirewallaClient();
  });

  describe('Alarm Response Schema Validation', () => {
    it('should validate alarm list response schema', () => {
      const alarmResponse = mockResponses.alarms;
      
      // Validate top-level structure
      expect(alarmResponse).toHaveProperty('items');
      expect(alarmResponse).toHaveProperty('total');
      expect(Array.isArray(alarmResponse.items)).toBe(true);
      expect(typeof alarmResponse.total).toBe('number');
      
      // Validate alarm item schema
      if (alarmResponse.items.length > 0) {
        const alarm = alarmResponse.items[0];
        expect(alarm).toHaveProperty('aid');
        expect(alarm).toHaveProperty('type');
        expect(alarm).toHaveProperty('severity');
        expect(alarm).toHaveProperty('message');
        expect(typeof alarm.aid).toBe('string');
        expect(typeof alarm.type).toBe('string');
        expect(typeof alarm.severity).toBe('string');
        expect(typeof alarm.message).toBe('string');
      }
    });

    it('should validate alarm severity values', () => {
      const validSeverities = ['low', 'medium', 'high', 'critical'];
      const alarmResponse = mockResponses.alarms;
      
      alarmResponse.items.forEach(alarm => {
        expect(validSeverities).toContain(alarm.severity);
      });
    });
  });

  describe('Flow Response Schema Validation', () => {
    it('should validate flow list response schema', () => {
      const flowResponse = mockResponses.flows;
      
      // Validate paginated response structure
      expect(flowResponse).toHaveProperty('items');
      expect(flowResponse).toHaveProperty('total');
      expect(Array.isArray(flowResponse.items)).toBe(true);
      
      // Validate flow item schema
      if (flowResponse.items.length > 0) {
        const flow = flowResponse.items[0];
        expect(flow).toHaveProperty('fd');
        expect(flow).toHaveProperty('sh');
        expect(flow).toHaveProperty('dh');
        expect(flow).toHaveProperty('protocol');
        expect(typeof flow.fd).toBe('string');
        expect(typeof flow.sh).toBe('string');
        expect(typeof flow.dh).toBe('string');
        expect(typeof flow.protocol).toBe('string');
      }
    });
  });

  describe('Device Response Schema Validation', () => {
    it('should validate device list response schema', () => {
      const deviceResponse = mockResponses.devices;
      
      expect(deviceResponse).toHaveProperty('items');
      expect(deviceResponse).toHaveProperty('total');
      expect(Array.isArray(deviceResponse.items)).toBe(true);
      
      if (deviceResponse.items.length > 0) {
        const device = deviceResponse.items[0];
        expect(device).toHaveProperty('id');
        expect(device).toHaveProperty('name');
        expect(device).toHaveProperty('ip');
        expect(device).toHaveProperty('mac');
        expect(device).toHaveProperty('online');
        expect(typeof device.id).toBe('string');
        expect(typeof device.name).toBe('string');
        expect(typeof device.online).toBe('boolean');
      }
    });
  });

  describe('Rule Response Schema Validation', () => {
    it('should validate rule list response schema', () => {
      const ruleResponse = mockResponses.rules;
      
      expect(ruleResponse).toHaveProperty('items');
      expect(ruleResponse).toHaveProperty('total');
      expect(Array.isArray(ruleResponse.items)).toBe(true);
      
      if (ruleResponse.items.length > 0) {
        const rule = ruleResponse.items[0];
        expect(rule).toHaveProperty('rid');
        expect(rule).toHaveProperty('type');
        expect(rule).toHaveProperty('action');
        expect(rule).toHaveProperty('enabled');
        expect(typeof rule.rid).toBe('string');
        expect(typeof rule.type).toBe('string');
        expect(typeof rule.action).toBe('string');
        expect(typeof rule.enabled).toBe('boolean');
      }
    });

    it('should validate rule action values', () => {
      const validActions = ['allow', 'block', 'timelimit', 'log'];
      const ruleResponse = mockResponses.rules;
      
      ruleResponse.items.forEach(rule => {
        expect(validActions).toContain(rule.action);
      });
    });
  });

  describe('Statistics Response Schema Validation', () => {
    it('should validate statistics response schema', () => {
      const statsResponse = mockResponses.statistics;
      
      // Validate numeric statistics
      expect(typeof statsResponse.total_devices).toBe('number');
      expect(typeof statsResponse.online_devices).toBe('number');
      expect(typeof statsResponse.total_alarms).toBe('number');
      expect(typeof statsResponse.critical_alarms).toBe('number');
      expect(typeof statsResponse.total_rules).toBe('number');
      expect(typeof statsResponse.active_rules).toBe('number');
      
      // Validate logical constraints
      expect(statsResponse.online_devices).toBeLessThanOrEqual(statsResponse.total_devices);
      expect(statsResponse.critical_alarms).toBeLessThanOrEqual(statsResponse.total_alarms);
      expect(statsResponse.active_rules).toBeLessThanOrEqual(statsResponse.total_rules);
    });
  });

  describe('Handler Response Format Validation', () => {
    it('should validate MCP unified response format', async () => {
      // Test a representative handler
      const handler = registry.getHandler('get_active_alarms');
      expect(handler).toBeDefined();
      
      if (handler) {
        // Setup mock to return our schema-validated response
        mockClient.getActiveAlarms.mockResolvedValue(mockResponses.alarms);
        
        const result = await handler.execute({ limit: 5 }, mockClient);
        
        // Validate MCP response format
        expect(result).toBeDefined();
        expect(result).toHaveProperty('content');
        expect(Array.isArray(result.content)).toBe(true);
        
        // Should have at least one content block
        expect(result.content.length).toBeGreaterThan(0);
        
        // Content blocks should have proper structure
        result.content.forEach(block => {
          expect(block).toHaveProperty('type');
          expect(['text', 'image'].includes(block.type)).toBe(true);
        });
      }
    });
  });

  describe('Error Response Schema Validation', () => {
    it('should validate error response format', async () => {
      const handler = registry.getHandler('get_active_alarms');
      expect(handler).toBeDefined();
      
      if (handler) {
        // Test missing required parameter
        const result = await handler.execute({}, mockClient);
        
        // Should return error in unified format (uses isError, not error)
        expect(result).toHaveProperty('isError');
        expect(result.isError).toBe(true);
        expect(result).toHaveProperty('content');
        expect(Array.isArray(result.content)).toBe(true);
        
        // Error content should be descriptive
        expect(result.content.length).toBeGreaterThan(0);
        const errorBlock = result.content.find(block => block.type === 'text');
        expect(errorBlock).toBeDefined();
        expect(errorBlock.text).toContain('limit');
      }
    });
  });
});