/**
 * @fileoverview Simple Smoke Tests for Tool Categories
 * 
 * Basic smoke tests to verify that each category of tools can be instantiated
 * and has the basic expected functionality. This is part of the simple testing
 * suite for the Firewalla MCP server.
 * 
 * Tests:
 * - Security tools smoke test
 * - Network tools smoke test
 * - Device tools smoke test
 * - Rule tools smoke test
 * - Analytics tools smoke test
 * - Search tools smoke test
 * - Bulk operation tools smoke test
 * - Convenience tools smoke test
 */

import { ToolRegistry } from '../../src/tools/registry.js';

import { createMockFirewallaClient } from '../mocks/mockFirewallaClient.js';

// Create mock client with all methods
const mockFirewallaClient = createMockFirewallaClient();

describe('Simple Smoke Tests for Tool Categories', () => {
  let registry: ToolRegistry;
  let mockClient: any;

  beforeEach(() => {
    registry = new ToolRegistry();
    mockClient = mockFirewallaClient;
  });

  /**
   * Validates that a handler result matches the MCP unified-response contract:
   *   • either { error: true, content: Block[] }
   *   • or     { content: Block[] }
   */
  const validateUnifiedResponse = (result: any) => {
    expect(result).toBeDefined();
    if (result.error) {
      expect(result.content).toBeDefined();
      expect(Array.isArray(result.content)).toBe(true);
    } else {
      expect(result.content).toBeDefined();
      expect(Array.isArray(result.content)).toBe(true);
    }
  };

  describe('Security Tools Smoke Tests', () => {
    it('should have security tools available and callable', async () => {
      const securityTools = registry.getToolsByCategory('security');
      expect(securityTools.length).toBeGreaterThan(0);
      
      console.log(`🔒 Testing ${securityTools.length} security tools`);
      
      for (const tool of securityTools) {
        expect(tool.name).toBeTruthy();
        expect(tool.category).toBe('security');
        expect(tool.description).toBeTruthy();
        expect(typeof tool.execute).toBe('function');
        
        console.log(`  ✅ ${tool.name} - ${tool.description.slice(0, 60)}...`);
      }
    });

    it('should execute get_active_alarms and return a unified response', async () => {
      const handler = registry.getHandler('get_active_alarms');
      if (handler) {
        const result = await handler.execute({ limit: 5 }, mockClient as any);
        validateUnifiedResponse(result);
      }
    });
  });

  describe('Network Tools Smoke Tests', () => {
    it('should have network tools available and callable', async () => {
      const networkTools = registry.getToolsByCategory('network');
      expect(networkTools.length).toBeGreaterThan(0);
      
      console.log(`🌐 Testing ${networkTools.length} network tools`);
      
      for (const tool of networkTools) {
        expect(tool.name).toBeTruthy();
        expect(tool.category).toBe('network');
        expect(tool.description).toBeTruthy();
        expect(typeof tool.execute).toBe('function');
        
        console.log(`  ✅ ${tool.name} - ${tool.description.slice(0, 60)}...`);
      }
    });

    it('should execute get_flow_data and return a unified response', async () => {
      const handler = registry.getHandler('get_flow_data');
      if (handler) {
        const result = await handler.execute({ limit: 5 }, mockClient as any);
        validateUnifiedResponse(result);
      }
    });
  });

  describe('Device Tools Smoke Tests', () => {
    it('should have device tools available and callable', async () => {
      const deviceTools = registry.getToolsByCategory('device');
      expect(deviceTools.length).toBeGreaterThan(0);
      
      console.log(`📱 Testing ${deviceTools.length} device tools`);
      
      for (const tool of deviceTools) {
        expect(tool.name).toBeTruthy();
        expect(tool.category).toBe('device');
        expect(tool.description).toBeTruthy();
        expect(typeof tool.execute).toBe('function');
        
        console.log(`  ✅ ${tool.name} - ${tool.description.slice(0, 60)}...`);
      }
    });

    it('should execute get_device_status and return a unified response', async () => {
      const handler = registry.getHandler('get_device_status');
      if (handler) {
        const result = await handler.execute({ limit: 5 }, mockClient as any);
        validateUnifiedResponse(result);
      }
    });
  });

  describe('Rule Tools Smoke Tests', () => {
    it('should have rule tools available and callable', async () => {
      const ruleTools = registry.getToolsByCategory('rule');
      expect(ruleTools.length).toBeGreaterThan(0);
      
      console.log(`📋 Testing ${ruleTools.length} rule tools`);
      
      for (const tool of ruleTools) {
        expect(tool.name).toBeTruthy();
        expect(tool.category).toBe('rule');
        expect(tool.description).toBeTruthy();
        expect(typeof tool.execute).toBe('function');
        
        console.log(`  ✅ ${tool.name} - ${tool.description.slice(0, 60)}...`);
      }
    });

    it('should execute get_network_rules and return a unified response', async () => {
      const handler = registry.getHandler('get_network_rules');
      if (handler) {
        const result = await handler.execute({ limit: 5 }, mockClient as any);
        validateUnifiedResponse(result);
      }
    });
  });

  describe('Analytics Tools Smoke Tests', () => {
    it('should have analytics tools available and callable', async () => {
      const analyticsTools = registry.getToolsByCategory('analytics');
      expect(analyticsTools.length).toBeGreaterThan(0);
      
      console.log(`📊 Testing ${analyticsTools.length} analytics tools`);
      
      for (const tool of analyticsTools) {
        expect(tool.name).toBeTruthy();
        expect(tool.category).toBe('analytics');
        expect(tool.description).toBeTruthy();
        expect(typeof tool.execute).toBe('function');
        
        console.log(`  ✅ ${tool.name} - ${tool.description.slice(0, 60)}...`);
      }
    });

    it('should execute get_simple_statistics and return a unified response', async () => {
      const handler = registry.getHandler('get_simple_statistics');
      if (handler) {
        const result = await handler.execute({}, mockClient as any);
        validateUnifiedResponse(result);
      }
    });
  });

  describe('Search Tools Smoke Tests', () => {
    it('should have search tools available and callable', async () => {
      const searchTools = registry.getToolsByCategory('search');
      expect(searchTools.length).toBeGreaterThan(0);
      
      console.log(`🔍 Testing ${searchTools.length} search tools`);
      
      for (const tool of searchTools) {
        expect(tool.name).toBeTruthy();
        expect(tool.category).toBe('search');
        expect(tool.description).toBeTruthy();
        expect(typeof tool.execute).toBe('function');
        
        console.log(`  ✅ ${tool.name} - ${tool.description.slice(0, 60)}...`);
      }
    });

    it('should execute search_flows and return a unified response', async () => {
      const handler = registry.getHandler('search_flows');
      if (handler) {
        const result = await handler.execute({ query: 'protocol:tcp', limit: 5 }, mockClient as any);
        validateUnifiedResponse(result);
      }
    });
  });

  describe('Convenience Tools Smoke Tests', () => {
    it('should have convenience tools available and callable', async () => {
      const convenienceTools = registry.getToolsByCategory('convenience');
      
      if (convenienceTools.length > 0) {
        console.log(`🛠️ Testing ${convenienceTools.length} convenience tools`);
        
        for (const tool of convenienceTools) {
          expect(tool.name).toBeTruthy();
          expect(tool.category).toBe('convenience');
          expect(tool.description).toBeTruthy();
          expect(typeof tool.execute).toBe('function');
          
          console.log(`  ✅ ${tool.name} - ${tool.description.slice(0, 60)}...`);
        }
      } else {
        console.log('🛠️ No convenience tools found (this is okay)');
      }
    });
  });

  describe('Cross-Category Integration', () => {
    it('should have tools that work across categories', () => {
      const allTools = registry.getToolNames();
      const toolsByCategory = new Map<string, number>();
      
      allTools.forEach(toolName => {
        const handler = registry.getHandler(toolName);
        if (handler) {
          const category = handler.category;
          toolsByCategory.set(category, (toolsByCategory.get(category) || 0) + 1);
        }
      });
      
      console.log('📈 Tool distribution summary:');
      Array.from(toolsByCategory.entries())
        .sort(([, a], [, b]) => b - a)
        .forEach(([category, count]) => {
          console.log(`  - ${category}: ${count} tools`);
        });
      
      // Should have tools in multiple categories
      expect(toolsByCategory.size).toBeGreaterThan(3);
    });

    it('should have consistent naming patterns within categories', () => {
      const searchTools = registry.getToolNames().filter(name => name.startsWith('search_'));
      const getTools = registry.getToolNames().filter(name => name.startsWith('get_'));
      const bulkTools = registry.getToolNames().filter(name => name.startsWith('bulk_'));
      
      console.log(`📝 Naming pattern analysis:`);
      console.log(`  - search_* tools: ${searchTools.length}`);
      console.log(`  - get_* tools: ${getTools.length}`);
      console.log(`  - bulk_* tools: ${bulkTools.length}`);
      
      // Verify consistent naming helps with tool discovery
      expect(searchTools.length + getTools.length + bulkTools.length).toBeGreaterThan(0);
    });
  });

  describe('Tool Metadata Quality', () => {
    it('should have quality descriptions for all tools', () => {
      const allTools = registry.getToolNames();
      let shortDescriptions = 0;
      let missingDescriptions = 0;
      
      allTools.forEach(toolName => {
        const handler = registry.getHandler(toolName);
        if (handler) {
          if (!handler.description || handler.description.trim().length === 0) {
            missingDescriptions++;
          } else if (handler.description.length < 20) {
            shortDescriptions++;
          }
        }
      });
      
      console.log(`📚 Description quality check:`);
      console.log(`  - Tools with good descriptions: ${allTools.length - shortDescriptions - missingDescriptions}`);
      console.log(`  - Tools with short descriptions: ${shortDescriptions}`);
      console.log(`  - Tools with missing descriptions: ${missingDescriptions}`);
      
      // Most tools should have decent descriptions
      expect(missingDescriptions).toBeLessThan(allTools.length * 0.1); // Less than 10% missing
    });

    it('should have reasonable schema complexity', () => {
      const allTools = registry.getToolNames();
      let toolsWithParams = 0;
      let toolsWithManyParams = 0;
      
      allTools.forEach(toolName => {
        const handler = registry.getHandler(toolName);
        if (handler && handler.schema && handler.schema.properties) {
          const paramCount = Object.keys(handler.schema.properties).length;
          if (paramCount > 0) {
            toolsWithParams++;
          }
          if (paramCount > 5) {
            toolsWithManyParams++;
          }
        }
      });
      
      console.log(`⚙️ Parameter complexity analysis:`);
      console.log(`  - Tools with parameters: ${toolsWithParams}`);
      console.log(`  - Tools with many parameters (>5): ${toolsWithManyParams}`);
      
      // Some tools should have parameters (more realistic expectation)
      expect(toolsWithParams).toBeGreaterThan(allTools.length * 0.1);
    });
  });
});