/**
 * @fileoverview Simple Error Handling Tests
 * 
 * Basic tests to validate that MCP tools return helpful error messages
 * and handle error conditions gracefully.
 * This is part of the simple testing suite for the Firewalla MCP server.
 * 
 * Tests:
 * - Unknown tool handling
 * - Invalid parameter handling
 * - Network error simulation
 * - Error message format
 */

import { ToolRegistry } from '../../src/tools/registry.js';

// Mock FirewallaClient that can simulate errors
class MockFirewallaClientWithErrors {
  private shouldError: boolean = false;
  private errorType: string = 'network';

  setErrorMode(shouldError: boolean, errorType: string = 'network') {
    this.shouldError = shouldError;
    this.errorType = errorType;
  }

  async getAlarmData() {
    if (this.shouldError) {
      if (this.errorType === 'network') {
        throw new Error('Network connection failed');
      } else if (this.errorType === 'auth') {
        throw new Error('Authentication failed');
      } else if (this.errorType === 'timeout') {
        throw new Error('Request timeout');
      }
    }
    return { data: [], count: 0 };
  }

  async getFlowData() {
    if (this.shouldError) {
      throw new Error('Flow data retrieval failed');
    }
    return { data: [], count: 0 };
  }

  async getDeviceData() {
    if (this.shouldError) {
      throw new Error('Device data retrieval failed');
    }
    return { data: [], count: 0 };
  }
}

describe('Simple Error Handling Tests', () => {
  let registry: ToolRegistry;
  let mockClient: MockFirewallaClientWithErrors;

  beforeEach(() => {
    registry = new ToolRegistry();
    mockClient = new MockFirewallaClientWithErrors();
  });

  describe('Unknown Tool Handling', () => {
    it('should handle requests for non-existent tools gracefully', () => {
      const unknownTools = [
        'non_existent_tool',
        'invalid_tool_name',
        'get_magic_data',
        ''
      ];

      unknownTools.forEach(toolName => {
        const handler = registry.getHandler(toolName);
        expect(handler).toBeUndefined();
      });

      console.log('✅ Unknown tools return undefined as expected');
    });

    it('should provide helpful suggestions for similar tool names', () => {
      // Test case-sensitivity and similar names
      const similarToolTests = [
        { requested: 'GET_ACTIVE_ALARMS', expected: 'get_active_alarms' },
        { requested: 'search_flow', expected: 'search_flows' },
        { requested: 'get_alarm', expected: 'get_active_alarms' }
      ];

      similarToolTests.forEach(({ requested, expected }) => {
        const requestedHandler = registry.getHandler(requested);
        const expectedHandler = registry.getHandler(expected);
        
        expect(requestedHandler).toBeUndefined();
        expect(expectedHandler).toBeDefined();
      });

      console.log('✅ Case sensitivity and exact name matching work correctly');
    });
  });

  describe('Invalid Parameter Error Handling', () => {
    it('should handle invalid parameters gracefully without crashing', async () => {
      const testCases = [
        { tool: 'get_active_alarms', params: { limit: 'invalid' } },
        { tool: 'search_flows', params: { query: 123 } },
        { tool: 'get_specific_alarm', params: { alarm_id: null } },
        { tool: 'pause_rule', params: { rule_id: undefined } }
      ];

      for (const { tool, params } of testCases) {
        const handler = registry.getHandler(tool);
        
        if (handler) {
          try {
            const result = await handler.execute(params, mockClient as any);
            
            // Should return a result (success or error) without crashing
            expect(result).toBeDefined();
            console.log(`✅ ${tool} handles invalid parameters gracefully`);
          } catch (error) {
            // Exceptions are acceptable, but should be meaningful
            expect(error).toBeInstanceOf(Error);
            expect(error.message.length).toBeGreaterThan(0);
            console.log(`✅ ${tool} throws meaningful error for invalid parameters`);
          }
        }
      }
    });

    it('should provide specific error messages for missing required parameters', async () => {
      const requiredParamTests = [
        { tool: 'get_specific_alarm', missingParam: 'alarm_id' },
        { tool: 'delete_alarm', missingParam: 'alarm_id' },
        { tool: 'pause_rule', missingParam: 'rule_id' },
        { tool: 'resume_rule', missingParam: 'rule_id' }
      ];

      for (const { tool, missingParam } of requiredParamTests) {
        const handler = registry.getHandler(tool);
        
        if (handler) {
          try {
            const result = await handler.execute({}, mockClient as any);
            
            // Check if error mentions the missing parameter
            if (result.error && result.content) {
              const errorText = result.content[0]?.text || '';
              // Should mention the missing parameter or be a validation error
              expect(errorText.length).toBeGreaterThan(5);
              console.log(`✅ ${tool} provides error for missing ${missingParam}`);
            }
          } catch (error) {
            // Exception should mention the missing parameter
            expect(error.message.length).toBeGreaterThan(5);
            console.log(`✅ ${tool} exception mentions missing parameter`);
          }
        }
      }
    });
  });

  describe('Network Error Simulation', () => {
    it('should handle network errors gracefully', async () => {
      mockClient.setErrorMode(true, 'network');
      
      const networkDependentTools = [
        'get_active_alarms',
        'get_flow_data',
        'get_device_status'
      ];

      for (const toolName of networkDependentTools) {
        const handler = registry.getHandler(toolName);
        
        if (handler) {
          try {
            const result = await handler.execute({ limit: 10 }, mockClient as any);
            
            // Should handle network error gracefully
            expect(result).toBeDefined();
            if (result.error) {
              console.log(`✅ ${toolName} handles network errors gracefully`);
            }
          } catch (error) {
            // Exception is acceptable for network errors
            expect(error).toBeInstanceOf(Error);
            console.log(`✅ ${toolName} throws appropriate error for network failure`);
          }
        }
      }
    });

    it('should handle authentication errors appropriately', async () => {
      mockClient.setErrorMode(true, 'auth');
      
      const handler = registry.getHandler('get_active_alarms');
      
      if (handler) {
        try {
          const result = await handler.execute({ limit: 10 }, mockClient as any);
          
          expect(result).toBeDefined();
          console.log('✅ Authentication errors handled gracefully');
        } catch (error) {
          expect(error).toBeInstanceOf(Error);
          console.log('✅ Authentication errors throw appropriate exceptions');
        }
      }
    });
  });

  describe('Error Message Format and Quality', () => {
    it('should return errors in consistent format', async () => {
      const handler = registry.getHandler('get_active_alarms');
      
      if (handler) {
        try {
          // Test with various invalid inputs
          const invalidInputs = [
            {},
            { limit: -1 },
            { limit: 'invalid' },
            { invalidParam: true }
          ];

          for (const input of invalidInputs) {
            try {
              const result = await handler.execute(input, mockClient as any);
              
              if (result.error) {
                // Check error format consistency
                expect(result).toHaveProperty('error');
                expect(result.error).toBe(true);
                
                if (result.content) {
                  expect(Array.isArray(result.content)).toBe(true);
                  expect(result.content.length).toBeGreaterThan(0);
                }
              }
            } catch (error) {
              // Exception format is also acceptable
              expect(error).toBeInstanceOf(Error);
            }
          }
          
          console.log('✅ Error format consistency validated');
        } catch (error) {
          console.log('✅ Error handling works consistently');
        }
      }
    });

    it('should provide actionable error messages', async () => {
      const handler = registry.getHandler('search_flows');
      
      if (handler) {
        try {
          // Test with missing required parameters
          const result = await handler.execute({}, mockClient as any);
          
          if (result.error && result.content) {
            const errorText = result.content[0]?.text || '';
            
            // Error message should be actionable (mention what's needed)
            expect(errorText.length).toBeGreaterThan(10);
            console.log('✅ Error messages are actionable');
          }
        } catch (error) {
          expect(error.message.length).toBeGreaterThan(10);
          console.log('✅ Exception messages are descriptive');
        }
      }
    });
  });

  describe('Error Recovery Information', () => {
    it('should provide recovery suggestions when appropriate', async () => {
      const searchHandler = registry.getHandler('search_flows');
      
      if (searchHandler) {
        try {
          const result = await searchHandler.execute({ 
            query: '', // Empty query
            limit: 10 
          }, mockClient as any);
          
          // Should handle empty query gracefully
          expect(result).toBeDefined();
          console.log('✅ Empty query handled appropriately');
        } catch (error) {
          console.log('✅ Empty query validation works');
        }
      }
    });

    it('should handle edge cases without crashing', async () => {
      const edgeCases = [
        { tool: 'get_active_alarms', params: { limit: 0 } },
        { tool: 'get_active_alarms', params: { limit: 99999 } },
        { tool: 'search_flows', params: { query: 'a'.repeat(1000), limit: 1 } }
      ];

      for (const { tool, params } of edgeCases) {
        const handler = registry.getHandler(tool);
        
        if (handler) {
          try {
            const result = await handler.execute(params, mockClient as any);
            expect(result).toBeDefined();
            console.log(`✅ ${tool} handles edge case gracefully`);
          } catch (error) {
            expect(error).toBeInstanceOf(Error);
            console.log(`✅ ${tool} handles edge case with appropriate error`);
          }
        }
      }
    });
  });
});