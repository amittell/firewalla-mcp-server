/**
 * @fileoverview Direct Schema Validation Tests
 * 
 * Tests that validate the TOOL_SCHEMAS export from server.ts directly.
 * This ensures all tool schemas are properly defined and valid.
 */

import { extractToolSchemas } from '../helpers/extract-schemas.js';

// Extract TOOL_SCHEMAS directly from server.ts
const TOOL_SCHEMAS = extractToolSchemas();

describe('Direct Schema Validation Tests', () => {
  describe('TOOL_SCHEMAS Structure', () => {
    it('should export TOOL_SCHEMAS with expected structure', () => {
      expect(TOOL_SCHEMAS).toBeDefined();
      expect(typeof TOOL_SCHEMAS).toBe('object');
      
      // Get all tool names
      const toolNames = Object.keys(TOOL_SCHEMAS);
      console.log(`✅ Found ${toolNames.length} tools in TOOL_SCHEMAS`);
      
      // Verify we have the expected number of tools (24 in TOOL_SCHEMAS)
      // Note: Registry has 33 total including convenience tools registered separately
      expect(toolNames.length).toBe(24);
    });

    it('should have valid schema structure for all tools', () => {
      const toolNames = Object.keys(TOOL_SCHEMAS);
      let validCount = 0;
      let invalidCount = 0;
      const errors: string[] = [];

      toolNames.forEach(toolName => {
        try {
          const schema = TOOL_SCHEMAS[toolName as keyof typeof TOOL_SCHEMAS];
          
          // Validate required properties
          expect(schema).toHaveProperty('name');
          expect(schema.name).toBe(toolName);
          expect(schema).toHaveProperty('description');
          expect(typeof schema.description).toBe('string');
          expect(schema.description.length).toBeGreaterThan(10);
          expect(schema).toHaveProperty('inputSchema');
          expect(schema.inputSchema).toHaveProperty('type');
          expect(schema.inputSchema.type).toBe('object');
          
          // Validate inputSchema properties if present
          if (schema.inputSchema.properties) {
            expect(typeof schema.inputSchema.properties).toBe('object');
          }
          
          // Validate required array if present
          if (schema.inputSchema.required) {
            expect(Array.isArray(schema.inputSchema.required)).toBe(true);
            // Check that required fields exist in properties
            schema.inputSchema.required.forEach(field => {
              if (schema.inputSchema.properties) {
                expect(schema.inputSchema.properties).toHaveProperty(field);
              }
            });
          }
          
          validCount++;
        } catch (error) {
          invalidCount++;
          errors.push(`${toolName}: ${error.message}`);
        }
      });

      console.log(`✅ Schema validation: ${validCount} valid, ${invalidCount} invalid`);
      if (errors.length > 0) {
        console.error('Schema validation errors:', errors);
      }
      
      // All schemas should be valid
      expect(invalidCount).toBe(0);
    });

    it('should have proper parameter types in schemas', () => {
      const validTypes = ['string', 'number', 'boolean', 'array', 'object'];
      const toolNames = Object.keys(TOOL_SCHEMAS);
      let parameterCount = 0;
      let validParameterCount = 0;

      toolNames.forEach(toolName => {
        const schema = TOOL_SCHEMAS[toolName as keyof typeof TOOL_SCHEMAS];
        
        if (schema.inputSchema.properties) {
          Object.entries(schema.inputSchema.properties).forEach(([paramName, paramSchema]) => {
            parameterCount++;
            
            if (paramSchema.type && validTypes.includes(paramSchema.type)) {
              validParameterCount++;
            } else {
              console.warn(`Invalid parameter type for ${toolName}.${paramName}: ${paramSchema.type}`);
            }
          });
        }
      });

      console.log(`✅ Parameter validation: ${validParameterCount}/${parameterCount} parameters have valid types`);
      
      // Most parameters should have valid types
      expect(validParameterCount).toBeGreaterThan(parameterCount * 0.95);
    });
  });

  describe('Tool Categories', () => {
    it('should have tools organized by expected categories', () => {
      const toolNames = Object.keys(TOOL_SCHEMAS);
      const categories = {
        security: ['get_active_alarms', 'get_specific_alarm', 'delete_alarm'],
        network: ['get_flow_data', 'get_bandwidth_usage', 'get_flow_trends'],
        device: ['get_device_status', 'get_online_devices'],
        rule: ['get_network_rules', 'get_most_active_rules', 'get_recent_rules', 'pause_rule', 'resume_rule'],
        analytics: ['get_simple_statistics'],
        search: ['search_flows', 'search_alarms', 'search_rules', 'search_devices', 'search_cross_reference'],
        convenience: ['get_offline_devices'] // Note: allow_ip/allow_domain are registered separately
      };

      // Verify core tools exist
      Object.entries(categories).forEach(([category, tools]) => {
        tools.forEach(tool => {
          if (toolNames.includes(tool)) {
            expect(TOOL_SCHEMAS).toHaveProperty(tool);
            console.log(`✅ ${category} tool '${tool}' found in TOOL_SCHEMAS`);
          }
        });
      });
    });
  });

  describe('Required Parameters', () => {
    it('should enforce limit parameter for paginated tools', () => {
      const paginatedTools = [
        'get_active_alarms',
        'get_flow_data',
        'get_device_status',
        'get_bandwidth_usage',
        'get_network_rules',
        'get_most_active_rules',
        'get_recent_rules',
        'search_flows',
        'search_alarms',
        'search_rules',
        'search_devices'
      ];

      paginatedTools.forEach(toolName => {
        if (TOOL_SCHEMAS[toolName as keyof typeof TOOL_SCHEMAS]) {
          const schema = TOOL_SCHEMAS[toolName as keyof typeof TOOL_SCHEMAS];
          
          // Check that limit is in required array
          if (schema.inputSchema.required) {
            expect(schema.inputSchema.required).toContain('limit');
          }
          
          // Check that limit is defined in properties
          if (schema.inputSchema.properties) {
            expect(schema.inputSchema.properties).toHaveProperty('limit');
            expect(schema.inputSchema.properties.limit.type).toBe('number');
          }
          
          console.log(`✅ ${toolName} has required limit parameter`);
        }
      });
    });

    it('should have proper required fields for write operations', () => {
      const writeOperations = {
        'delete_alarm': ['alarm_id'],
        'pause_rule': ['rule_id'],
        'resume_rule': ['rule_id'],
        'allow_ip': ['ip', 'duration'],
        'allow_domain': ['domain', 'duration']
      };

      Object.entries(writeOperations).forEach(([toolName, requiredFields]) => {
        if (TOOL_SCHEMAS[toolName as keyof typeof TOOL_SCHEMAS]) {
          const schema = TOOL_SCHEMAS[toolName as keyof typeof TOOL_SCHEMAS];
          
          requiredFields.forEach(field => {
            if (schema.inputSchema.required) {
              expect(schema.inputSchema.required).toContain(field);
            }
            if (schema.inputSchema.properties) {
              expect(schema.inputSchema.properties).toHaveProperty(field);
            }
          });
          
          console.log(`✅ ${toolName} has all required fields for write operation`);
        }
      });
    });
  });

  describe('Schema Consistency', () => {
    it('should have consistent naming conventions', () => {
      const toolNames = Object.keys(TOOL_SCHEMAS);
      const validNamePattern = /^[a-z][a-z0-9_]*$/;
      
      toolNames.forEach(toolName => {
        expect(toolName).toMatch(validNamePattern);
        
        // Tool name in schema should match the key
        const schema = TOOL_SCHEMAS[toolName as keyof typeof TOOL_SCHEMAS];
        expect(schema.name).toBe(toolName);
      });
      
      console.log('✅ All tool names follow consistent naming conventions');
    });

    it('should have meaningful descriptions', () => {
      const toolNames = Object.keys(TOOL_SCHEMAS);
      const minDescriptionLength = 20;
      
      toolNames.forEach(toolName => {
        const schema = TOOL_SCHEMAS[toolName as keyof typeof TOOL_SCHEMAS];
        
        expect(schema.description).toBeDefined();
        expect(schema.description.length).toBeGreaterThan(minDescriptionLength);
        
        // Description should mention key functionality
        const lowerDesc = schema.description.toLowerCase();
        const hasKeyword =
          lowerDesc.includes('retrieve') ||
          lowerDesc.includes('get') ||
          lowerDesc.includes('search') ||
          lowerDesc.includes('delete') ||
          lowerDesc.includes('pause') ||
          lowerDesc.includes('resume') ||
          lowerDesc.includes('allow') ||
          lowerDesc.includes('analyze') ||
          lowerDesc.includes('list') ||
          lowerDesc.includes('find') ||
          lowerDesc.includes('view') ||
          lowerDesc.includes('show') ||
          lowerDesc.includes('statistics') ||
          lowerDesc.includes('trends') ||
          lowerDesc.includes('query') ||
          lowerDesc.includes('check') ||
          lowerDesc.includes('disable') ||
          lowerDesc.includes('enable');
        
        if (!hasKeyword) {
          console.warn(`Tool ${toolName} description doesn't contain expected keywords: "${schema.description}"`);
        }
        expect(hasKeyword).toBe(true);
      });
      
      console.log('✅ All tools have meaningful descriptions');
    });
  });

  describe('Convenience Tools Validation', () => {
    it('should have get_offline_devices in TOOL_SCHEMAS', () => {
      const toolNames = Object.keys(TOOL_SCHEMAS);
      
      // TOOL_SCHEMAS has get_offline_devices
      expect(toolNames).toContain('get_offline_devices');
      
      // Note: allow_ip and allow_domain are registered separately in the registry
      // They are not in TOOL_SCHEMAS but are convenience wrappers
      expect(toolNames).not.toContain('allow_ip');
      expect(toolNames).not.toContain('allow_domain');
      
      console.log('✅ TOOL_SCHEMAS contains get_offline_devices (allow_ip/allow_domain are registered separately)');
    });
  });
});